from __future__ import annotations

import difflib
from pathlib import Path
from typing import Dict, List, Any

from .identity import get_project_root, get_timestamp
from .logging import log, log_section
from .hardening_content import get_template


def _read_file(path: Path) -> str:
    if not path.exists():
        return ""
    try:
        return path.read_text(encoding="utf-8")
    except OSError:
        return ""


def _write_backup(path: Path) -> None:
    if not path.exists():
        return
    try:
        backup = path.with_suffix(path.suffix + ".bak")
        backup.write_text(path.read_text(encoding="utf-8"), encoding="utf-8")
        log("Backup created", context={"file": str(backup)})
    except OSError as exc:
        log(
            "Failed to create backup",
            level="ERROR",
            context={"file": str(path), "error": str(exc)},
        )


def _write_file(path: Path, content: str) -> None:
    _write_backup(path)
    try:
        path.write_text(content, encoding="utf-8")
        log("Wrote hardened content", context={"file": str(path)})
    except OSError as exc:
        log(
            "Failed to write hardened content",
            level="ERROR",
            context={"file": str(path), "error": str(exc)},
        )


def _diff_content(original: str, hardened: str) -> str:
    diff = difflib.unified_diff(
        original.splitlines(),
        hardened.splitlines(),
        fromfile="current",
        tofile="hardened",
        lineterm="",
    )
    return "\n".join(diff)


def harden_file(path: Path, dry_run: bool = True) -> Dict[str, Any]:
    """
    Harden a single file against the canonical template, if one exists.

    Args:
        path: Path to the file.
        dry_run: If True, show diff only; if False, apply changes with backup.

    Returns:
        A dict describing:
        - file: file path
        - changed: bool
        - diff: unified diff (may be empty)
        - skipped: bool
    """
    filename = path.name
    hardened = get_template(filename)
    if not hardened:
        return {
            "file": str(path),
            "changed": False,
            "diff": "",
            "skipped": True,
        }

    current = _read_file(path)
    diff = _diff_content(current, hardened)
    changed = current != hardened

    if changed and not dry_run:
        _write_file(path, hardened)

    return {
        "file": str(path),
        "changed": changed,
        "diff": diff,
        "skipped": False,
    }


def ensure_init_files(dry_run: bool = True) -> List[str]:
    """
    Ensure every Python package directory has an __init__.py.

    This walks the project root and adds __init__.py to directories that appear
    to contain Python modules but are missing the file.

    Args:
        dry_run: If True, report what would be created; if False, create the files.

    Returns:
        A list of paths where __init__.py was (or would be) created.
    """
    created: List[str] = []
    root = get_project_root()

    for path in root.rglob("*"):
        if path.is_dir():
            init_file = path / "__init__.py"
            # Skip hidden and venv directories explicitly
            if any(part.startswith(".") for part in path.parts):
                continue
            if "venv" in path.parts or "__pycache__" in path.parts:
                continue

            if not init_file.exists():
                created.append(str(init_file))
                if not dry_run:
                    try:
                        init_file.write_text(
                            "# Auto-generated by The Veil Updater\n",
                            encoding="utf-8",
                        )
                        log(
                            "Created __init__.py",
                            context={"file": str(init_file)},
                        )
                    except OSError as exc:
                        log(
                            "Failed to create __init__.py",
                            level="ERROR",
                            context={"file": str(init_file), "error": str(exc)},
                        )

    return created


def run_updater(dry_run: bool = True) -> Dict[str, Any]:
    """
    Run the full hardening/updater routine.

    - Applies templates to top-level files (README.md, CONTRIBUTING.md, etc.).
    - Ensures __init__.py exists where appropriate.
    - Logs actions and results.

    Args:
        dry_run: If True, only compute diffs and report; no writes.

    Returns:
        A structured dict describing the run.
    """
    log_section("Updater Run")

    root = get_project_root()
    results: List[Dict[str, Any]] = []

    top_level_targets = [
        "README.md",
        "CONTRIBUTING.md",
        "__init__.py",
    ]

    for filename in top_level_targets:
        path = root / filename
        results.append(harden_file(path, dry_run=dry_run))

    init_created = ensure_init_files(dry_run=dry_run)

    summary = {
        "timestamp": get_timestamp(),
        "dry_run": dry_run,
        "results": results,
        "init_created": init_created,
    }

    log("Updater completed", context={"dry_run": dry_run, "init_created_count": len(init_created)})
    return summary
